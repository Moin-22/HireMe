import io
import uuid
from fastapi import FastAPI, UploadFile, File, HTTPException
from pydantic import BaseModel
from pypdf import PdfReader  
from contextlib import asynccontextmanager

# Import our graph
from app.graph.workflow import app_graph

app = FastAPI()

class UserAnswer(BaseModel):
    session_id: str
    answer: str

@app.post("/start-interview")
async def start_interview(file: UploadFile = File(...)):
    """
    Uploads a PDF, reads it using pypdf, and starts the interview.
    """
    # 1. READ THE FILE CONTENT
    content = await file.read()
    filename = file.filename.lower()
    resume_text = ""

    # 2. USE PYPDF TO EXTRACT TEXT
    try:
        if filename.endswith(".pdf"):
            # Create a stream from the raw bytes
            pdf_stream = io.BytesIO(content)
            reader = PdfReader(pdf_stream)
            
            # Loop through pages and extract text
            for page in reader.pages:
                resume_text += page.extract_text() or ""
        else:
            # Fallback for .txt files
            resume_text = content.decode("utf-8")
            
    except Exception as e:
        print(f"Error reading PDF: {e}")
        resume_text = "Error reading resume. Proceeding with generic questions."

    # 3. GENERATE SESSION
    session_id = str(uuid.uuid4())
    
    # 4. INITIALIZE GRAPH STATE
    initial_state = {
        "resume_text": resume_text,
        "max_questions": 13,
        "question_count": 0,
        "messages": [],
        "feedback_reports": []
    }

    # 5. RUN GRAPH (Get First Question)
    config = {"configurable": {"thread_id": session_id}}
    
    # Run until it pauses at the user input
    for event in app_graph.stream(initial_state, config):
        pass 
    
    # Get the question generated by the agent
    snapshot = app_graph.get_state(config)
    current_q = snapshot.values.get("current_question", "Could not generate question.")

    return {
        "session_id": session_id,
        "message": current_q
    }

@app.post("/submit-answer")
async def submit_answer(payload: UserAnswer):
    session_id = payload.session_id
    config = {"configurable": {"thread_id": session_id}}

    # 1. CHECK SESSION
    snapshot = app_graph.get_state(config)
    if not snapshot.values:
        raise HTTPException(status_code=404, detail="Session not found")

    # 2. UPDATE HISTORY WITH USER ANSWER
    current_messages = snapshot.values.get("messages", [])
    updated_messages = current_messages + [payload.answer]
    app_graph.update_state(config, {"messages": updated_messages})

    # 3. RESUME GRAPH
    final_message = "Error generating response."
    status = "in_progress"

    # Stream allows us to see which node is running
    for event in app_graph.stream(None, config):
        for node_name, value in event.items():
            if node_name == "feedback":
                status = "completed"
                final_message = value.get("current_question", "Thank you.")
            elif node_name == "question_gen":
                final_message = value.get("current_question", "Next question...")

    return {
        "status": status,
        "message": final_message
    }